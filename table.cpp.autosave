#include "table.h"
#include <QDebug>
static const string DBadd="D:\\testsssbin\\";
Table::Table(const string& tableName):tableName(tableName)
{
    add=DBadd+tableName;
    cout<<add<<endl;
    //未找到该表
    if(!readFromFile(tableName)) cerr<<"Error finding tabel."<<endl;
    line_num=lines.size();
    row_num=0;
    for (const auto& str : rows)
        row_num++;
}

Table::Table(const vector<tableRows>& newTable,const string& tableName):tableName(tableName),rows(newTable)
{
    CreateTable(rows,tableName);
    add=DBadd+tableName;
    line_num=0;
    //rows=newTable;
    row_num=0;
    for (const auto& str : rows)
        row_num++;
}

Table::~Table()
{

}

void Table::test()
{
cout<<add;
getContrain("stduent");
for(auto ppp:lines)cout<<ppp<<endl;

}

bool Table::dropTable()
{
    QString add_Q=QString::fromStdString(add);
    QDir dir(add_Q);
    if (!dir.exists())
    {
        qDebug() << "Folder does not exist:" << add_Q;
        return false;
    }

    if (dir.removeRecursively())
    {
        qDebug() << "Folder deleted successfully:" << add_Q;
        return true;
    }
    else
    {
        qDebug() << "Error deleting folder:" << add_Q;
        return false;
    }
}

bool Table::instertTOTable(const string& content, const string& correspond)
{
    this_row.clear();
    this_row=rows;
    string newline="";
    vector<string> correspond_v=splitByPipe(correspond);//列名
    vector<string>  content_v=splitByPipe(content);//每列对应内容
    //content先全赋值为默认值
    for(auto thing: this_row)
    {
        thing.content=thing.default_content;
    }
    //先解析是否有对应的列要求
    if(correspond!="")//有要求插入（）
    {
        if(content_v.size()!=rows.size()||correspond_v.size()!=rows.size())//数目不一直接报错
        {
            cerr<<"no matching insert error"<<endl;
            return false;
        }
        else
        {
            for(unsigned j =0;j<correspond_v.size();++j)//对每个列名进行检查，不存在相关列名直接报错,将其插入当前列
            {
                unsigned int i=0;
                bool flag=true;
                while (i<rows.size()&&flag)
                {
                    rows[i].rowName==correspond_v[j]?flag=false:++i;
                }
                if(i>=rows.size())
                {
                    cerr<<"no such row!error"<<endl;
                    return false;
                }
                else
                {
                    //检查限制

                    if(!checkType(this_row[i].rowType,content_v[j]))//检查类型错误
                    {
                        cerr<<"type wrong!error"<<endl;
                        return false;
                    }
                    if(this_row[i].constrainMessage==true&&!checkConstrains(getContrain(this_row[i].rowName),this_row[i].rowType,content_v[j]))
                    {
                        cerr<<"cannot insert for constrain limitations!"<<endl;
                        return false;
                    }
                    this_row[i].content=content_v[j];

                }
            }
        }
    }
    else //无要求插入，默认插入
    {
        if(content_v.size()!=rows.size())//数目不一直接报错
        {
            cerr<<" no matching insert error"<<endl;
            return false;
        }
        else
        {
            for(unsigned int i=0;i<(unsigned int)row_num;++i)
            {
                if(!checkType(this_row[i].rowType,content_v[i]))//检查类型错误
                {
                    cerr<<"type wrong!error"<<endl;
                    return false;
                }
                //检查限制
                if(this_row[i].constrainMessage==true&&!checkConstrains(getContrain(this_row[i].rowName),this_row[i].rowType,content_v[i]))
                {
                    cerr<<"cannot insert for constrain limitations!"<<endl;
                    return false;
                }
                this_row[i].content=content_v[i];
            }
        }
    }
    //将当前列数据写成newline插入lines
    for(unsigned int i=0;i<this_row.size();++i)
    {
        newline.append(this_row[i].content);
        if(i<this_row.size()-1)//最后一个属性后不打|
         newline.append("|");
    }
    //插入lines（内存暂存表结构）
    cout<<"newline"<<newline<<" linenum"<<lines.size();
    lines.push_back(newline);
    line_num++;
    //是否需要在此处保存？
    saveToFile();
    return true;
}
//old version
//bool Table::instertTOTable(const string& content, const string& correspond)
//{
//    this_row.clear();
//    this_row=rows;
//    string newline="";
//    vector<string> correspond_v=splitByPipe(correspond);//列名
//    vector<string>  content_v=splitByPipe(content);//每列对应内容
//    //先解析是否有对应的列要求
//    if(correspond!="")//有要求插入（）
//    {
//        if(content_v.size()!=rows.size()||correspond_v.size()!=rows.size())//数目不一直接报错
//        {
//            cerr<<"no matching insert error"<<endl;
//            return false;
//        }
//        else
//        {
//            for(unsigned j =0;j<correspond_v.size();++j)//对每个列名进行检查，不存在相关列名直接报错,将其插入当前列
//            {
//                unsigned int i=0;
//                bool flag=true;
//                while (i<rows.size()&&flag)
//                {
//                    rows[i].rowName==correspond_v[j]?flag=false:++i;
//                }
//                if(i>=rows.size())
//                {
//                    cerr<<"no such row!error"<<endl;
//                    return false;
//                }
//                else
//                {
//                    if(!checkType(this_row[i].rowType,content_v[j]))//检查类型错误
//                    {
//                        cerr<<"type wrong!error"<<endl;
//                        return false;
//                    }
//                    else
//                    {
//                        this_row[i].content=content_v[j];
//                    }
//                }
//            }
//        }
//    }
//    else //无要求插入，默认插入
//    {
//        if(content_v.size()!=rows.size())//数目不一直接报错
//        {
//            cerr<<" no matching insert error"<<endl;
//            return false;
//        }
//        else
//        {
//            for(int i=0;i<row_num;++i)
//            {
//                if(!checkType(this_row[i].rowType,content_v[i]))//检查类型错误
//                {
//                    cerr<<"type wrong!error"<<endl;
//                    return false;
//                }
//                else
//                {
//                    this_row[i].content=content_v[i];
//                }
//            }
//        }
//    }
//    //将当前列数据写成newline插入lines
//    for(unsigned int i=0;i<this_row.size();++i)
//    {
//        newline.append(this_row[i].content);
//        if(i<this_row.size()-1)//最后一个属性后不打|
//         newline.append("|");
//    }
//    //插入lines（内存暂存表结构）
//    lines.push_back(newline);
//    line_num++;
//    //是否需要在此处保存？
//    saveToFile();
//    return true;
//}

bool Table::deleteFromTable(const delete_mode& mode,const vector<string>&rowname,const vector<string>&constrainMessage)
{

    if(mode==delete_mode::ALL)//清空整个表
    {
        ofstream file_C(add+"\\content.bin",ios::binary);
        if (!file_C.is_open())
        {
            cerr << "Error opening file " <<endl;
            return false;
        }
        else
        {
            lines.clear();
            file_C.write("",0);
            cout<<"delete successfully!"<<endl;
        }

        file_C.close();
        return true;
    }
    else if (mode==delete_mode::SELECT)//带限制的删除
    {
        //储存删除后的新表
        vector<string>new_lines;
        //先检查列限制数目是否匹配
        if(rowname.size()!=constrainMessage.size())
        {
            cerr<<"num in delete !not match !"<<endl;
            return false;
        }
        //获得限制所在的列，便于操作
        vector<unsigned int> aim_row;//目标列所在编号
        for(unsigned int i=0;i<rowname.size();++i)
        {
            for(unsigned int j=0;j<(unsigned)row_num;++j)
            {
                if(rowname[i]==rows[j].rowName)
                    aim_row.push_back(j);
            }
        }
        if(rowname.size()!=aim_row.size())
        {
            cerr<<"now such row !"<<endl;
            return false;
        }
        //逐行检测,i为行号
        for(unsigned int i=0;i<(unsigned int)line_num;++i)
        {
            checkLines(lines[i]);
            bool flag=true;
            //vector<bool>checks;
            for(unsigned int j=0;j<aim_row.size();++j)//每一个限制检查
            {
               flag*=checkConstrains(constrainMessage[j],this_row[aim_row[j]].rowType,this_row[aim_row[j]].content);//快睡着了写的，可能有错误
                cout<<flag<<endl;
            }
            //检查是否符合所有约束,不符合就保留
           if(!flag) new_lines.push_back(lines[i]);
        }
        lines=new_lines;
        //for(auto ppp:lines)cout<<ppp<<endl;
        //保存文件
        saveToFile();
        return true;
    }
    else return false;

}

//实在不想写了，这里只能修改一列，sql修改多列就多次调用
bool Table::alterTable(const Table::alter_mode &mode, const Table::alter_class &class_A, const string &content)
{
    if(mode==alter_mode::DROP&&class_A==alter_class::ROW)//删除列
    {
        //
    }
    else if(mode==alter_mode::DROP&&class_A==alter_class::PRIMARY_KRY)//删除主键
    {
        vector<string> rownames=splitByPipe(content);
        for(auto name:rownames)
        {
            unsigned int i=0;
            for(;i<(unsigned int)row_num;++i)
            {
                if(rows[i].rowName==name&&rows[i].isPrimaryKey==true)
                    rows[i].isPrimaryKey=false;
                else if (rows[i].isPrimaryKey==false)
                {
                    cerr<<rows[i].rowName<<"is not primary,change stop here!"<<endl;
                    return false;
                }
            }
            if (i>=(unsigned int)row_num)
            {
                cerr<<"no such row,change stop here!"<<endl;
                return false;
            }
        }
    }
    else if(mode==alter_mode::DROP&&class_A==alter_class::CONSTRAIN)//删除约束
    {

    }
    else if(mode==alter_mode::ADD&&class_A==alter_class::ROW)//增加列
    {

    }
    else if(mode==alter_mode::ADD&&class_A==alter_class::CONSTRAIN)//增加约束
    {

    }
//    else if(mode==alter_mode::DROP&&class_A==alter_class::ROW)增加索引
//    {

//    }
    else if(mode==alter_mode::RENAME&&class_A==alter_class::ROW)
    {

    }
    else if(mode==alter_mode::RENAME&&class_A==alter_class::TABLE)
    {
        //qt改文件名
        QString oldDirPath = QString::fromStdString(add);
        cout<<add<<endl;
        QString newDirPath = QString::fromStdString(content);
        cout<<content<<endl;
    // 确保旧的目录存在
        QDir oldDir(oldDirPath);
        if (!oldDir.exists()) {
            cout<< "Directory does not exist:" << oldDirPath.toStdString();
            return false;
        }

        // 确保新的目录路径的父目录存在
        QDir newDirParent = QDir(QFileInfo(newDirPath).absolutePath());
        if (!newDirParent.exists()) {
           cout<< "Parent directory of new path does not exist:" << newDirParent.absolutePath().toStdString();
            return false;
        }

        // 尝试重命名目录
        bool success = QDir().rename(oldDirPath, newDirPath);
        if (!success) {
            cout<< "Failed to rename directory from" << oldDirPath.toStdString() << "to" << newDirPath.toStdString();
        }

        return success;
    }
    else if(mode==alter_mode::MODIFY&&class_A==alter_class::ROW)
    {

    }
    else
    {
        cerr<<"wrong mode!!"<<endl;
        return false;
    }
    return true;
}

bool Table::updateTable(const vector<string>&rowname,const vector<string>&goal,const vector<string>&constrainMessage)
{
    //传入数据不符合规范，直接报错
    if(rowname.size()!=goal.size())
    {
        cerr<<"wrong data!"<<endl;
        readFromFile(tableName);//防止lines存在已经修改数据
        return false;
    }
    unsigned int size=rowname.size();
    vector<unsigned int> aim_row;//目标列所在编号
    //储存更新后的新表
    vector<string>new_lines;
    for(unsigned int i=0;i<size;++i)//对每个项目（set）进行检查
    {
        //先查找是否有这样的列checkType(rows[j].rowType,goal[i])
        unsigned int j=0;

        for(;j<(unsigned int)row_num;++j)
        {
            if(rows[j].rowName==rowname[i])//找到了这样的列
            {
                aim_row.push_back(j);
                if(checkType(rows[j].rowType,goal[i]))//检查update的目标类型是否合规
                {
                    //检查更新的数据是否合规||限制
                    if(rows[j].constrainMessage==true&&checkConstrains(getContrain(rows[j].rowName),rows[j].rowType,goal[i]))
                    break;
                    else if(rows[j].constrainMessage==false) break;
                    else
                    {
                        cerr<<"wrong goal type"<<endl;
                        return false;
                    }
                }
                else
                {
                    cerr<<"wrong type!"<<endl;
                    readFromFile(tableName);//防止lines存在已经修改数据
                    return false;
                }
            }
        }
        if(j>=(unsigned int)row_num)//没有找到这样的列
        {
            cerr<<"no such row!"<<endl;
            readFromFile(tableName);//防止lines存在已经修改数据
            return false;
        }       
    }
     //提取的列数目不足
    if(aim_row.size()!=rowname.size())
    {
        cerr<<"wrong row name num!"<<endl;
    }

    //再查找where限制的行，删除这个行并将content更新到新行上
    //注意，每个return false前加一个readFromFile(tableName);
    //逐行检测,i为行号
    for(unsigned int i=0;i<lines.size();++i)
    {
        checkLines(lines[i]);
        bool flag=true;
        //vector<bool>checks;
        for(unsigned int j=0;j<aim_row.size();++j)//每一个限制检查
        {
           flag*=checkConstrains(constrainMessage[j],this_row[aim_row[j]].rowType,this_row[aim_row[j]].content);
        }
        //检查是否符合所有约束,不符合就保留，符合就更改
        for(auto poi:this_row)
            cout<<poi.content<<endl;
       if(flag) //符合就更改
       {
           for(unsigned int t=0;t<aim_row.size();++t)
           {
               this_row[aim_row[t]].content=goal[t];
           }
           for(auto poi:this_row)
               cout<<poi.content<<endl;
           string newline;
           for(unsigned int t=0;t<this_row.size();++t)
           {
               cout<<9859559<<this_row[t].content<<endl;
               newline.append(this_row[t].content);
               if(t<this_row.size()-1)//最后一个属性后不打|
                newline.append("|");
           }
           new_lines.push_back(newline);
       }
       else//不符合就保留
       {
           cout<<777<<endl;
            string newline=lines[i];
           new_lines.push_back(newline);
       }
    }
    for(auto poi:new_lines)
        cout<<poi<<endl;
    cout<<new_lines.size()<<endl;
    lines=new_lines;
    //保存
    saveToFile();
    return true;
}

void Table::checkLines(const string& in)//获得一列到类中，进行操作
{
    this_row.clear();
    vector<string> contents=splitByPipe(in);
    this_row=rows;
    for(unsigned int i=0;i<rows.size();++i)
    {
        this_row[i].content=contents[i];
    }
}

string Table::getContrain(const string& rowname)
{
    string fileName=add+"\\"+rowname+"constrains.bin";
    cout<<fileName<<endl;
    QFile file(QString::fromStdString(fileName));
        if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
            // 处理打开文件失败的情况
            qWarning() << "Could not open file:" << fileName.c_str();
            return std::string(); // 返回一个空字符串或抛出异常
        }

        QTextStream in(&file);
        QString content = in.readAll();

        file.close();
        return content.toStdString(); // 将QString转换为std::string
}

bool Table::setContrain(const string &rowname,const string& contents)
{
    // 将std::string转换为QString
        string filePath=add+"\\"+rowname+"constrains.bin";
        QString filePathQString = QString::fromStdString(filePath);
        QString contentQString = QString::fromStdString(contents);

        // 创建QFile对象
        QFile file(filePathQString);

        // 打开文件以写入，如果文件不存在则创建它
        if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
            // 处理打开文件失败的情况
            qWarning() << "Could not open file for writing:" << filePathQString;
            return false;
        }

        // 创建QTextStream对象以写入文件
        QTextStream out(&file);

        // 写入内容
        out << contentQString;

        // 关闭文件
        file.close();

        return true;
}




bool Table::CreateTable(const vector<tableRows>& newTable,const string& tableName)
{
    QDir dir;
    //要改成常量
    QString tableDirPath = QString::fromStdString(DBadd+tableName);
    string tableDirPath1=DBadd+tableName;
    //创建表文件夹,文件夹内存放表相关信息文件
    if (!dir.exists(tableDirPath))
    {
          // 如果不存在，创建文件夹
          if (dir.mkpath(tableDirPath))
          {
              qDebug() << "Folder created successfully at" << tableDirPath;
          }
          else
          {
              qDebug() << "Error creating folder.";
              return false;
          }
      }
    else
    {
          qDebug() << "Folder already exists at" << tableDirPath;
           return false;
    }

//    //处理newTable结构体数据
//    vector<string> attribute;//属性值
//    cout<<"done"<<endl;
//    for (const auto& str : newTable)
//    {
//        attribute.push_back(str.rowName);
//        //
//        //
//        //
//        //
//        //
//        //
//        //
//        //
//        //
//        //
//    }

    //创建属性文件
    ofstream file_A(tableDirPath1+"\\attribute.bin",ios::binary);
    //ofstream file_A("aaaaaaa.bin",ios::binary);
    if (file_A.is_open())
    {
        cout<<"createFile"+tableDirPath1+"\\attribute.bin"<<endl;
        for (const auto& s: newTable)
        {
            file_A << s.rowName << "|"
                   << s.rowType << "|"
                   << s.isPrimaryKey << "|"
                  << s.forignKeyName << "|"
                << s.forignKeyTable << "|"
                   << s.default_content<< "|"
                      << s.constrainMessage<< "|"
                         <<  "\n";
        }
        file_A.close();
    }
    else
    {
        cerr << "Error opening file " <<tableDirPath1+"\\attribute"<<endl;
        return false;
    }
    //创建表文件
    ofstream file_C(tableDirPath1+"\\content.bin",ios::binary);
    if (file_C.is_open())
    {
        cout<<"创建文件"+tableDirPath1+"\\content.bin"<<endl;
        file_C.close();
    }
    else
    {
        cerr << "Error opening file " <<endl;
        return false;
    }
    return true;
}

bool Table::saveToFile(save_mode mode)
{
    //写入表中数据
    if(mode==save_mode::BOTH||mode==save_mode::CONTENT)
    {
        ofstream file_C(add+"\\content.bin",ios::binary);
        if (!file_C.is_open())
        {
            cerr << "Error opening file " <<endl;
            return false;
        }
        for (const auto& str : lines)
        {
            file_C.write(str.c_str(), str.size());
            file_C.write("\n",1); // 写入分行符
        }
        file_C.close();
    }
    if(mode==save_mode::BOTH||mode==save_mode::ATTRIBUTE)
    {
        ofstream file_A(add+"\\attribute.bin",ios::binary);
        if (!file_A.is_open())
        {
            cerr << "Error opening file " <<endl;
            return false;
        }
        for (const auto& s : rows)//直接写入结构体
        {
            file_A << s.rowName << "|"
                   << s.rowType << "|"
                   << s.isPrimaryKey << "|"
                  << s.forignKeyName << "|"
                << s.forignKeyTable << "|"
                   << s.default_content<< "|"
                      << s.constrainMessage<< "|"
                         <<  "\n";
        }
        file_A.close();
    }
    return true;
}

bool Table::readFromFile(const string& tableName)
{
    const char delimiter = '\n';
    QDir dir;
    //要改成常量
    QString tableDirPath = QString::fromStdString(DBadd+tableName);
    //表不存在返回false
    if (!dir.exists(tableDirPath))
    {
        return false;
    }
    //创建文件输入流
    //1.读取表中数据
    lines.clear();
    ifstream file_C(add+"\\content.bin",ios::binary);
    if (file_C.is_open())
    {
        string str;
        while (std::getline(file_C, str, delimiter))
        { // 以分隔符为界读取字符串
            lines.push_back(str);
        }
        file_C.close();
    }
    else
    {
        cerr << "Error opening file: " << add+"\\content.bin" << endl;
        return false;
    }
    //2.读取表中属性
    rows.clear();
    ifstream file_A(add+"\\attribute.bin",ios::binary);
    if (file_A.is_open())
    {
        string line;
        while (getline(file_A, line))
        {
            tableRows row;
            //字符流
            stringstream ss(line);
            string item;
            //rowName
            getline(ss, item, '|');
            row.rowName = item;
            //rowType
            getline(ss, item, '|');
            row.rowType = static_cast<type>(stoi(item));
            //isPrimaryKey
            getline(ss, item, '|');
            row.isPrimaryKey = static_cast<bool>(stoi(item));
            //forignKeyName
            getline(ss, item, '|');
            row.forignKeyName = item;
            //forignKeyTable
            getline(ss, item, '|');
            row.forignKeyTable = item;
            //default_content
            getline(ss, item, '|');
            row.default_content = item;
            //constrainMessage
            getline(ss, item, '|');
            row.constrainMessage = static_cast<bool>(stoi(item));
            //row.rowConstrain = static_cast<constrain>(stoi(item));

            rows.push_back(row);
        }
        file_A.close();
        cout << "Data read from file successfully." << endl;
    }
    else
    {
        cerr << "Unable to open file: "  << endl;
    }
    return true;
}
// 打印函数
void Table::show() {
    // 打印表头
    for (const auto& row : rows) {
        std::cout << row.rowName << "\t";
    }
    std::cout << std::endl;

    // 打印分隔线
    for (size_t i = 0; i < rows.size(); ++i) {
        std::cout << "----\t";
    }
    std::cout << std::endl;

    // 打印每一行数据
    for (const auto& line : lines) {
        std::istringstream iss(line);
        std::string value;
        while (std::getline(iss, value, '|')) {
            std::cout << value << "\t";
        }
        std::cout << std::endl;
    }
}
